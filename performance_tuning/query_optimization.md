# Module SQLPT02: **Performance Tuning - Query Optimization**

> **Module Objective**
> This module aims to equip learners with essential skills for T-SQL query optimization. Learners will understand how to analyze query performance using execution plans, leverage database statistics, and apply various `SET` options to gain insights into query behavior, ultimately writing more efficient and faster SQL code.

## Learning Outcomes

By the end of this module, learners will be able to:

1.  Understand the role of the SQL Server Query Optimizer.
2.  Generate and interpret Estimated and Actual Execution Plans.
3.  Identify common performance bottlenecks in execution plans.
4.  Explain the importance of database statistics and how they are used.
5.  Utilize `SET STATISTICS IO` and `SET STATISTICS TIME` to measure query performance.
6.  Apply basic query rewriting techniques for optimization.

## Reference Materials

  - **Books:**
      - *SQL Server 2019 Query Performance Tuning Distilled* by Grant Fritchey
      - *SQL Server 2019 Internals* by Kalen Delaney, et al.
  - **Online Resources:**
      - Query Processing Architecture Guide (Microsoft Learn) ([https://learn.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide/query-processing-architecture-guide?view=sql-server-ver16](https://www.google.com/search?q=https://learn.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide/query-processing-architecture-guide))
      - Display an Actual Execution Plan (Microsoft Learn) ([https://learn.microsoft.com/en-us/sql/relational-databases/performance/display-an-actual-execution-plan?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/relational-databases/performance/display-an-actual-execution-plan?view=sql-server-ver16))
      - SQL Server Statistics (SQLShack) ([https://www.sqlshack.com/sql-server-statistics-a-complete-guide/](https://www.google.com/search?q=https://www.sqlshack.com/sql-server-statistics-a-complete-guide/))
      - SET STATISTICS IO (Transact-SQL) (Microsoft Learn) ([https://learn.microsoft.com/en-us/sql/t-sql/statements/set-statistics-io-transact-sql?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/t-sql/statements/set-statistics-io-transact-sql?view=sql-server-ver16))
      - SET STATISTICS TIME (Transact-SQL) (Microsoft Learn) ([https://learn.microsoft.com/en-us/sql/t-sql/statements/set-statistics-time-transact-sql?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/t-sql/statements/set-statistics-time-transact-sql?view=sql-server-ver16))

-----

## Key Concepts & Detailed Content

### 1\. **Introduction to Query Optimization**

  - **Definition**: Query optimization is the process of finding the most efficient way to execute a SQL query. The goal is to minimize resource consumption (CPU, I/O, memory) and execution time. The **SQL Server Query Optimizer** is a complex, cost-based engine that analyzes various execution strategies for a given query and selects the one estimated to have the lowest cost.
  - **Why Optimize?**:
      - **Faster Applications**: Improves response times for users.
      - **Reduced Resource Usage**: Less strain on the server, allowing more concurrent users or queries.
      - **Scalability**: Ensures applications perform well as data volumes grow.
  - **Key Tools for Optimization**:
      - **Execution Plans**: Visual representation of how SQL Server executes a query.
      - **Statistics**: Information about the data distribution in columns, crucial for the optimizer.
      - **`SET` Options**: Commands to gather performance metrics.

-----

### 2\. **Execution Plans**

  - **Definition**: An execution plan is a graphical or textual representation of the data retrieval and manipulation steps that SQL Server performs to execute a query. It shows the operations (e.g., table scan, index seek, hash match, sort) and their estimated costs.
  - **Types**:
      - **Estimated Plan**:
          - **Description**: Generated by the Query Optimizer *before* the query is executed. It's the optimizer's best guess at how the query will run, based on available statistics.
          - **How to Get**: In SSMS, click "Display Estimated Execution Plan" (Ctrl+L) or use `SET SHOWPLAN_ALL ON;` / `SET SHOWPLAN_TEXT ON;`.
          - **Use Case**: Quick analysis of potential execution paths without running the query, useful for syntax checking and initial performance assessment.
      - **Actual Plan**:
          - **Description**: Generated *after* the query has been executed. It shows the actual operations performed, including runtime statistics like actual rows, execution times, and I/O.
          - **How to Get**: In SSMS, click "Include Actual Execution Plan" (Ctrl+M) or use `SET STATISTICS PROFILE ON;` / `SET STATISTICS XML ON;`.
          - **Use Case**: Detailed analysis of query performance, identifying discrepancies between estimated and actual behavior, and pinpointing bottlenecks.
  - **Interpreting Execution Plans**:
      - **Operators**: Each icon represents a specific operation (e.g., `Table Scan`, `Index Seek`, `Hash Match`, `Sort`).
      - **Arrows**: Represent data flow. Thicker arrows mean more rows are processed.
      - **Costs**: Each operator has an associated cost (percentage of total query cost). High-cost operators are potential bottlenecks.
      - **Warnings**: Yellow exclamation marks indicate potential issues (e.g., missing index warnings, implicit conversions).
      - **Properties Window**: Provides detailed information for each operator (e.g., number of rows, I/O, CPU time, predicates).
  - **Common Bottlenecks in Plans**:
      - **Table Scan**: Reading every row in a table. Often indicates a missing or inappropriate index.
      - **Bookmark Lookup (Key Lookup / RID Lookup)**: Occurs when a non-clustered index is used to find rows, but additional columns not in the index are needed, forcing SQL Server to go back to the clustered index or heap for each row. Indicates a non-covering index.
      - **Sort**: High cost for sorting large datasets, often indicates a missing index for `ORDER BY` or `GROUP BY`.
      - **Hash Match / Merge Join**: While often efficient, can be costly for very large datasets if memory grants are insufficient.
      - **Implicit Conversion**: When data types are mismatched in comparisons or joins, SQL Server might perform implicit conversions, which can prevent index usage. Look for `CONVERT_IMPLICIT` warnings.

-----

### 3\. **Statistics and `SET` Options**

#### 3.1. **Statistics**

  - **Definition**: Statistics are objects that contain statistical information about the distribution of values in one or more columns of a table or indexed view. The Query Optimizer uses these statistics to estimate the cardinality (number of rows) of intermediate results, which helps it choose the most efficient execution plan.
  - **How SQL Server Uses Them**:
      - **Cardinality Estimation**: Predicts how many rows will be returned by an operation (e.g., a `WHERE` clause filter).
      - **Index Selection**: Helps decide which index (if any) to use.
      - **Join Order/Type**: Influences the choice of join algorithms (Nested Loops, Hash Match, Merge Join).
  - **`AUTO_UPDATE_STATISTICS`**:
      - **Explanation**: A database option that, when `ON` (default), allows SQL Server to automatically update statistics when the data in the indexed columns has changed significantly. This is crucial for the optimizer to have up-to-date information.
      - **`AUTO_CREATE_STATISTICS`**: (Also important) Automatically creates statistics on columns used in predicates of queries if no suitable index or statistics object already exists.
  - **Maintaining Statistics**:
      - `UPDATE STATISTICS table_name (index_or_column_name);`
      - `SP_UPDATESTATS;` (Updates all statistics in the current database)
      - `WITH FULLSCAN` or `WITH SAMPLE X PERCENT`: Specifies the amount of data to scan to build statistics. `FULLSCAN` is most accurate but takes longer.

#### 3.2. **`SET` Options for Performance Measurement**

  - **`SET STATISTICS IO ON`**:
      - **Description**: Displays information about the amount of disk activity generated by T-SQL statements. It shows logical reads (data pages read from cache), physical reads (data pages read from disk), and read-aheads.
      - **Use Case**: Identifying queries that perform excessive I/O, which is often a major bottleneck. Lower logical reads are generally better.
      - **Example Output**:
        ```
        Table 'Employees'. Scan count 1, logical reads 10, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
        ```
  - **`SET STATISTICS TIME ON`**:
      - **Description**: Displays the amount of time required to parse, compile, and execute each statement. It shows CPU time and elapsed time.
      - **Use Case**: Identifying queries that consume excessive CPU resources or have long execution durations.
      - **Example Output**:
        ```
        SQL Server parse and compile time:
           CPU time = 0 ms,  elapsed time = 0 ms.
        SQL Server Execution Times:
           CPU time = 15 ms,  elapsed time = 12 ms.
        ```
  - **How to Use**: Place these `SET` statements at the beginning of your query batch. Remember to set them `OFF` when done.
    ```sql
    SET STATISTICS IO ON;
    SET STATISTICS TIME ON;

    SELECT * FROM LargeTable WHERE SomeColumn = 'Value';

    SET STATISTICS IO OFF;
    SET STATISTICS TIME OFF;
    ```

#### 3.3. **Case Study: Query Rewriting for Optimization**

  - **Problem**: A query to find customers who have placed orders but have no email address is performing slowly.
    ```sql
    -- Original (potentially slow) query
    SELECT C.CustomerID, C.FirstName, C.LastName
    FROM Customers AS C
    WHERE C.Email IS NULL
      AND C.CustomerID IN (SELECT DISTINCT CustomerID FROM Orders);
    ```
  - **Analysis**: The `IN` subquery can be inefficient, especially if `Orders` is large or if there are many `NULL` emails.
  - **Optimization (using `EXISTS` or `JOIN`)**:
      - **Using `EXISTS` (often better for existence checks)**:
        ```sql
        SELECT C.CustomerID, C.FirstName, C.LastName
        FROM Customers AS C
        WHERE C.Email IS NULL
          AND EXISTS (SELECT 1 FROM Orders AS O WHERE O.CustomerID = C.CustomerID);
        ```
      - **Using `INNER JOIN` (if you want to see the order details too, or if optimizer prefers it)**:
        ```sql
        SELECT DISTINCT C.CustomerID, C.FirstName, C.LastName
        FROM Customers AS C
        INNER JOIN Orders AS O ON C.CustomerID = O.CustomerID
        WHERE C.Email IS NULL;
        ```
  - **Verification**: Compare the Actual Execution Plans, `STATISTICS IO`, and `STATISTICS TIME` for both queries to confirm the improvement. The `EXISTS` or `JOIN` version will likely show fewer logical reads and lower CPU/elapsed time.

-----

## Lab Exercises / Hands-On Practice

| \#   | Task                                                                     | Tool          | Outcome                                                               |
| --- | ------------------------------------------------------------------------ | ------------- | --------------------------------------------------------------------- |
| 1   | Create a `LargeCustomers` table (e.g., 100,000 rows) without any indexes. Run a `SELECT` query with a `WHERE` clause on a non-indexed column. Obtain and analyze the Estimated and Actual Execution Plans. | SSMS / Azure Data Studio | Plans show `Table Scan`; understanding of basic plan interpretation. |
| 2   | Use `SET STATISTICS IO ON` and `SET STATISTICS TIME ON` for the query in Task 1. Analyze the output for logical reads, CPU time, and elapsed time. | SSMS / Azure Data Studio | Metrics provide baseline performance data.                            |
| 3   | Create a non-clustered index on the column used in the `WHERE` clause from Task 1. Re-run the query and compare the new execution plan (should show `Index Seek`) and `STATISTICS IO/TIME` output. | SSMS / Azure Data Studio | Performance metrics improve; index usage is confirmed.                |
| 4   | Introduce an implicit conversion in a query (e.g., comparing a `VARCHAR` column to an `INT`). Observe the warning in the execution plan and its impact on index usage. | SSMS / Azure Data Studio | Warning appears; index might be ignored due to conversion.            |
| 5   | Rewrite a query that uses a scalar subquery in the `WHERE` clause to use a `JOIN` or `CTE` instead. Compare the execution plans and performance metrics. | SSMS / Azure Data Studio | Understanding of query rewriting for optimization.                    |

-----

## Assessments

### Knowledge Checks (MCQs)

1.  **Which of the following tools provides a graphical representation of how SQL Server executes a query?**

      - A) SQL Server Profiler
      - B) Activity Monitor
      - C) Execution Plan
      - D) SQL Server Agent
      - **Answer:** C) Execution Plan
      - **Explanation:** Execution plans (Estimated or Actual) visually depict the steps and operations SQL Server takes to run a query.

2.  **What does a "Table Scan" operator in an execution plan typically indicate?**

      - A) The query is highly optimized.
      - B) The query is using an efficient clustered index.
      - C) SQL Server is reading every row in the table, potentially indicating a missing index.
      - D) The query is performing a fast in-memory operation.
      - **Answer:** C) SQL Server is reading every row in the table, potentially indicating a missing index.
      - **Explanation:** A Table Scan means the entire table is being read, which is inefficient for large tables and often suggests that an appropriate index is missing for the query's filtering or sorting needs.

3.  **Which `SET` option is used to display information about the amount of disk activity (logical reads, physical reads) generated by a query?**

      - A) `SET SHOWPLAN_ALL ON`
      - B) `SET STATISTICS TIME ON`
      - C) `SET STATISTICS IO ON`
      - D) `SET ROWCOUNT ON`
      - **Answer:** C) `SET STATISTICS IO ON`
      - **Explanation:** `SET STATISTICS IO ON` provides detailed I/O statistics, including logical and physical reads, which are crucial for identifying I/O-bound queries.

### Short Answer Questions

1.  Explain the difference between an Estimated Execution Plan and an Actual Execution Plan, and when you would use each.
2.  What is the role of database statistics in query optimization, and why is it important to keep them up-to-date?
3.  Describe how an "implicit conversion" can negatively impact query performance and how to identify it in an execution plan.

### Practical Task

  - **Setup**: Create a table named `OrderDetails` with at least 50,000 rows.
      - `OrderDetailID` (INT PK Identity)
      - `OrderID` (INT)
      - `ProductID` (INT)
      - `Quantity` (INT)
      - `UnitPrice` (DECIMAL(10,2))
      - `LineTotal` (AS `Quantity * UnitPrice` PERSISTED)
      - `OrderDate` (DATETIME)
      - `CustomerCountry` (NVARCHAR(50))
  - **Tasks**:
    1.  **Baseline Performance**:
          - Run the following query:
            ```sql
            SELECT OrderID, ProductID, LineTotal
            FROM OrderDetails
            WHERE CustomerCountry = 'USA' AND OrderDate >= '2024-01-01'
            ORDER BY LineTotal DESC;
            ```
          - Enable `SET STATISTICS IO ON;` and `SET STATISTICS TIME ON;`.
          - Obtain the Actual Execution Plan.
          - Record the logical reads, CPU time, elapsed time, and identify the most costly operator in the plan.
    2.  **Index Optimization**:
          - Based on the query and the execution plan, create a non-clustered index that you believe will significantly improve its performance. Consider a covering index if appropriate.
          - Re-run the query from Task 1.
          - Compare the new `STATISTICS IO/TIME` output and the Actual Execution Plan. Explain the improvements observed.
    3.  **Statistics Update Impact**:
          - Simulate a scenario where statistics might be outdated (e.g., add another 50,000 rows to `OrderDetails` without auto-update kicking in, or disable auto-update temporarily for testing).
          - Run a query that relies heavily on a column with potentially outdated statistics.
          - Then, manually update statistics for that column with `FULLSCAN`.
          - Re-run the query and observe if the execution plan or performance metrics change.
    4.  **Clean up**: Drop all created indexes, and then drop the `OrderDetails` table.
